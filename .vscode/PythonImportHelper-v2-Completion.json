[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "TreeNode",
        "description": "TreeNode",
        "isExtraImport": true,
        "detail": "TreeNode",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "description": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "peekOfCode": "class Solution(object):\n    def longestConsecutive(self, nums):\n        hashset, maximum = set(nums), 0\n        for i in hashset:\n            if i-1 not in hashset:\n                sequence = 1\n                while (i+sequence) in hashset:\n                    sequence += 1\n                maximum = max(maximum, sequence)\n        return maximum",
        "detail": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "description": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "peekOfCode": "class Solution(object):\n    def productExceptSelf(self, nums):\n        answer = [0] * len(nums)\n        sum = 1\n        zeroIndex = -1\n        for i in range(len(nums)):\n            value = nums[i]\n            if value == 0:\n                if zeroIndex != -1:\n                    return answer",
        "detail": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "description": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "peekOfCode": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        topMap = [[] for _ in range(len(nums) + 1)]\n        map = self.mapify(nums)\n        for key in map:\n            value = map[key]\n            topMap[value].append(key)\n        j = 0\n        topK = [[] for _ in range(k)]\n        for i in range(len(topMap) - 1, -1, -1):",
        "detail": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "description": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "peekOfCode": "class Solution(object):\n    def isValidSudoku(self, board):\n        for rowIndex in range(len(board)):\n            row = board[rowIndex]\n            for colIndex in range(len(row)):\n                if not self.verify(board, rowIndex, colIndex):\n                    return False\n        return True\n    def verify(self, board, rowIndex, colIndex):\n        valid = True",
        "detail": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "description": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "peekOfCode": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nprint(Solution().isValidSudoku(board))",
        "detail": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.easy.704_Binary_Search.Solution",
        "description": "binary_search.easy.704_Binary_Search.Solution",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            middleIndex = l + ((r - l) // 2)\n            if nums[middleIndex] == target:\n                return middleIndex\n            if nums[middleIndex] < target:\n                l = middleIndex + 1\n            else:",
        "detail": "binary_search.easy.704_Binary_Search.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "description": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        l, r = 0, len(nums) - 1\n        res = nums[0]\n        while l <= r:\n            m = ( l + r ) // 2\n            res = min(res, nums[m])\n            if nums[l] < nums[r]:\n                return min(nums[l], res)\n            if(nums[m] == nums[l]):",
        "detail": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "description": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "peekOfCode": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        size = len(nums1) + len(nums2)\n        half = size // 2\n        #if nums2 is empty\n        if len(nums2) == 0:\n            size = len(nums1) - 1\n            if (size+1) % 2:\n                return nums1[size // 2] / 1\n            else:",
        "detail": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "description": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        l, r = 0, len(nums) - 1\n        res = nums[0]\n        while l <= r:\n            m = ( l + r ) // 2\n            res = min(res, nums[m])\n            if nums[l] <= nums[r]:\n                return min(nums[l], res)\n            if nums[m] >= nums[l]:",
        "detail": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "description": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] >= nums[l]:\n                if target > nums[m] or target < nums[l]:\n                    l = m + 1",
        "detail": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "description": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "peekOfCode": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        m = len(matrix)\n        n = len(matrix[0])\n        l, r = 0, (m * n) - 1\n        while l <= r:\n            m = (l + r) // 2\n            arrayIndex = m // n\n            cellIndex = m - (arrayIndex * n)\n            print(m)",
        "detail": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "description": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "peekOfCode": "class Solution(object):\n    def minEatingSpeed(self, piles, h):\n        l, r = 1, max(piles)\n        minimum = r\n        while l <= r:\n            k = (l + r) // 2\n            hours = 0\n            for p in piles:\n                hours += math.ceil(p / k)\n            if hours <= h:",
        "detail": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "documentation": {}
    },
    {
        "label": "TimeMap",
        "kind": 6,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "class TimeMap(object):\n    def __init__(self):\n        self.store = {}\n    def set(self, key, value, timestamp):\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])\n    def get(self, key, timestamp):\n        res = \"\"\n        if key not in self.store:",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "obj = TimeMap()\nobj.set(1, 1, 1)\nparam_2 = obj.get(1,1)\nprint(param_2)",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "param_2",
        "kind": 5,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "param_2 = obj.get(1,1)\nprint(param_2)",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "description": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        l, r = 0, (k - 1)\n        maximum = [0] * (len(nums) - r)\n        heap = []\n        # find max in first range\n        for i in range(l, r + 1):\n            heapq.heappush(heap, (-nums[i], i))  # store negation of elements in the heap\n        element = -heapq.heappop(heap)[0]  # negate the value again to get the maximum element\n        print(element)",
        "detail": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1025_Divisor_Game.Solution",
        "description": "dp.easy.1025_Divisor_Game.Solution",
        "peekOfCode": "class Solution(object):\n    def divisorGame(self, n):\n        return n&1 == 0\nprint(str(Solution().divisorGame(3)))",
        "detail": "dp.easy.1025_Divisor_Game.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "description": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "peekOfCode": "class Solution(object):\n    def tribonacci(self, n):\n        arr = [0, 1, 1]\n        if len(arr) >= n:\n            return arr[n]\n        for i in range(3, n):\n            num = arr[0] + arr[1] + arr[2]\n            self.leftShift(arr)\n            arr.append(num)\n        return self.sum(arr)",
        "detail": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "class Solution(object):\n    def generate(self, numRows):\n        dp = []\n        for i in range(1, numRows + 1):\n            array = []\n            for x in range(1, i+1):\n                if(x == 1 or x == i):\n                    array.append(1)\n                    continue\n                parent = dp[i - 2]",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.generate(3))",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.119_Pascals_Triangle_II.Solution",
        "description": "dp.easy.119_Pascals_Triangle_II.Solution",
        "peekOfCode": "class Solution(object):\n    def getRow(self, rowIndex):\n        arr = [0] * (rowIndex+1)\n        for row in range(rowIndex + 2):\n            startIndex = 0\n            endIndex = row-1\n            original = list(arr)\n            original[startIndex] = 1\n            original[endIndex] = 1\n            for col in range(row):",
        "detail": "dp.easy.119_Pascals_Triangle_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "description": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        left_pointer = 0\n        right_pointer = 1\n        max_profit = 0\n        for i in range(1, len(prices)):\n            value = prices[i]\n            if value < prices[left_pointer]:\n                left_pointer = i\n            right_pointer+=1",
        "detail": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "description": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def getMaximumGenerated(self, n):\n        if n < 2:\n            return n\n        arr = [0] * (n+1)\n        arr[1] = 1\n        max = arr[1]\n        for i in range(2, n+1):\n            if(i&1 == 0):\n                arr[i] = arr[i//2]",
        "detail": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "class Solution(object):\n    def countBits(self, n):\n        binary = [0]\n        msb = 1\n        for i in range(1, n + 1):\n            mbv = (2 ** msb)\n            if mbv == i:\n                msb+=1\n                binary.append(1)\n                continue",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.countBits(5))",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.392_Is_Subsequence.Solution",
        "description": "dp.easy.392_Is_Subsequence.Solution",
        "peekOfCode": "class Solution(object):\n    def isSubsequence(self, string, text):\n        subsequence = list(string)\n        j = 0\n        for i in range(len(text)):\n            if(text[i] == subsequence[j]):\n                char = subsequence[j]\n                j+=1\n                if(len(subsequence) == j):\n                    return True",
        "detail": "dp.easy.392_Is_Subsequence.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "description": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "peekOfCode": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        if len(cost) == 0:\n            return 0\n        if len(cost) == 1:\n            return cost[0]\n        if len(cost) == 2:\n            return min(cost[0], cost[1])\n        cost.append(0)\n        cost.append(0)",
        "detail": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "class Solution(object):\n    def allPossibleFBT(self, n):\n        #remember prev calculations\n        cache = {\n            0 : [],\n            1 : [TreeNode()]\n        }\n        #explore a given noumber of nodes\n        def explore(n):\n            #no full binary trees can be produced with an even number of nodes",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "result = Solution().allPossibleFBT(5)\nfor tree in result:\n    print(\"-\", tree)",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __str__(self):\n        return str(self.preorder(self))\n    def preorder(self, node):\n        if node is None:\n            return \"None\"",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + (str(self.next.val) if self.next else \"None\")\n        return res\nclass Solution(object):",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "class Solution(object):\n    def hasCycle2(self, head):\n        mapping = {}\n        index = 0\n        while head:\n            if head.next in mapping:\n                return mapping[head.next]\n            mapping[head] = index\n            head = head.next\n            index += 1 ",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node4 = ListNode(-4)\nnode3 = ListNode(0)\nnode2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node3 = ListNode(0)\nnode2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node1.next",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node1.next = node2\nnode2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node2.next",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node2.next = node3\nnode3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "node3.next",
        "kind": 5,
        "importPath": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "description": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "peekOfCode": "node3.next = node4\n# node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.easy.141_Linked_List_Cycle.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "description": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution(object):",
        "detail": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "description": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "peekOfCode": "class Solution(object):\n    def reverseList(self, head):\n        curr, prev = head, None\n        while curr:\n            #save the next list to explore\n            nxt = curr.next\n            #set the current val's next to the prev node\n            curr.next = prev\n            #set the new prev to explore, which is the curr nodes minus the curr value\n            prev = curr",
        "detail": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist",
        "kind": 5,
        "importPath": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "description": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "peekOfCode": "linkedlist = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().reverseList(linkedlist))",
        "detail": "linked_list.easy.206_Reverse_Linked_List.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "description": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution():",
        "detail": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "description": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "peekOfCode": "class Solution():\n    def mergeTwoLists(self, list1, list2):\n        root = ListNode()\n        tail = root\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2",
        "detail": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist1",
        "kind": 5,
        "importPath": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "description": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "peekOfCode": "linkedlist1 = ListNode(1, ListNode(2, ListNode(4)))\nlinkedlist2 = ListNode(1, ListNode(3, ListNode(4)))\nprint(Solution().mergeTwoLists(linkedlist1, linkedlist2))",
        "detail": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist2",
        "kind": 5,
        "importPath": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "description": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "peekOfCode": "linkedlist2 = ListNode(1, ListNode(3, ListNode(4)))\nprint(Solution().mergeTwoLists(linkedlist1, linkedlist2))",
        "detail": "linked_list.easy.21_Merge_Two_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "description": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + (str(self.next))\n        return res\nclass Solution(object):",
        "detail": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "description": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "peekOfCode": "class Solution(object):\n    def mergeKLists(self, lists):\n        #check if the lists are valid\n        if not lists and len(lists) == 0:\n            return None\n        #we will do a merge sort sorting two ll at a time\n        while len(lists) > 1:\n            currentlySorted = []\n            for i in range(0, len(lists), 2):\n                list1 = lists[i]",
        "detail": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist1",
        "kind": 5,
        "importPath": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "description": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "peekOfCode": "linkedlist1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nlinkedlist2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nlinkedlist3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().mergeKLists([linkedlist1, linkedlist2, linkedlist3]))\n# print(Solution().mergeTwoLists(linkedlist1, linkedlist2))",
        "detail": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist2",
        "kind": 5,
        "importPath": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "description": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "peekOfCode": "linkedlist2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nlinkedlist3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().mergeKLists([linkedlist1, linkedlist2, linkedlist3]))\n# print(Solution().mergeTwoLists(linkedlist1, linkedlist2))",
        "detail": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist3",
        "kind": 5,
        "importPath": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "description": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "peekOfCode": "linkedlist3 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().mergeKLists([linkedlist1, linkedlist2, linkedlist3]))\n# print(Solution().mergeTwoLists(linkedlist1, linkedlist2))",
        "detail": "linked_list.hard.23_Merge_k_Sorted_Lists.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "description": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + (str(self.next))\n        return res\nclass Solution(object):",
        "detail": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "description": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "peekOfCode": "class Solution(object):\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n        while True:\n            kth = self.getKthElement(groupPrev, k)\n            #the gruop does not exist, so lets just break out\n            if not kth:\n                break\n            groupNext = kth.next",
        "detail": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist1",
        "kind": 5,
        "importPath": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "description": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "peekOfCode": "linkedlist1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().reverseKGroup(linkedlist1, 2))",
        "detail": "linked_list.hard.25_Reverse_Nodes_in_k-Group.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x, nxt=None, random=None):\n        self.val = int(x)\n        self.next = nxt\n        self.random = random\n    def __str__(self) -> str:\n        res = str(self.val) + \"(\" + str(self.random) + \")\"\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "class Solution(object):\n    def copyRandomList(self, head):\n        #map all the nodes\n        mapping = {\n            None : None\n        }\n        curr = head\n        while curr:\n            mapping[curr] = ListNode(curr.val)\n            curr = curr.next",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "node5",
        "kind": 5,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "node5 = ListNode(1, None, None)\nnode4 = ListNode(10, node5, node5)\nnode3 = ListNode(11, node4, node5)\nnode2 = ListNode(13, node3, node4)\nnode1 = ListNode(7, node2, node3)\nprint(Solution().copyRandomList(node1))",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "node4 = ListNode(10, node5, node5)\nnode3 = ListNode(11, node4, node5)\nnode2 = ListNode(13, node3, node4)\nnode1 = ListNode(7, node2, node3)\nprint(Solution().copyRandomList(node1))",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "node3 = ListNode(11, node4, node5)\nnode2 = ListNode(13, node3, node4)\nnode1 = ListNode(7, node2, node3)\nprint(Solution().copyRandomList(node1))",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "node2 = ListNode(13, node3, node4)\nnode1 = ListNode(7, node2, node3)\nprint(Solution().copyRandomList(node1))",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "description": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "peekOfCode": "node1 = ListNode(7, node2, node3)\nprint(Solution().copyRandomList(node1))",
        "detail": "linked_list.meduim.138_Copy_List_with_Random_Pointer.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + (str(self.next.val) if self.next else \"None\")\n        return res\nclass Solution(object):",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "class Solution(object):\n    def hasCycle(self, head):\n        mapping = set()\n        while head:\n            if head.next in mapping:\n                return head.next\n            mapping.add(head)\n            head = head.next\n        return None\nnode4 = ListNode(-4)",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node4 = ListNode(-4)\nnode3 = ListNode(0)\nnode2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node3 = ListNode(0)\nnode2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node2 = ListNode(2)\nnode1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node1 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node1.next",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node2.next",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node2.next = node3\nnode3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node3.next",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node3.next = node4\nnode4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "node4.next",
        "kind": 5,
        "importPath": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "description": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "peekOfCode": "node4.next = node2\nprint(Solution().hasCycle(node1))",
        "detail": "linked_list.meduim.142_Linked_List_Cycle_II.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.143_Reorder_List.Solution",
        "description": "linked_list.meduim.143_Reorder_List.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution(object):",
        "detail": "linked_list.meduim.143_Reorder_List.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.143_Reorder_List.Solution",
        "description": "linked_list.meduim.143_Reorder_List.Solution",
        "peekOfCode": "class Solution(object):\n    def reorderList(self, head):\n        s, f = head, head.next\n        #partition\n        while f and f.next:\n            s = s.next\n            f = f.next.next\n        p1 = head\n        p2 = s.next\n        s.next = prev = None",
        "detail": "linked_list.meduim.143_Reorder_List.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist",
        "kind": 5,
        "importPath": "linked_list.meduim.143_Reorder_List.Solution",
        "description": "linked_list.meduim.143_Reorder_List.Solution",
        "peekOfCode": "linkedlist = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().reorderList(linkedlist))",
        "detail": "linked_list.meduim.143_Reorder_List.Solution",
        "documentation": {}
    },
    {
        "label": "DoublyListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.146_LRU_Cache.Solution",
        "description": "linked_list.meduim.146_LRU_Cache.Solution",
        "peekOfCode": "class DoublyListNode(object):\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.next = self.prev = None\nclass LRUCache(object):\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = DoublyListNode(0, 0)\n        self.tail = DoublyListNode(0, 0)        ",
        "detail": "linked_list.meduim.146_LRU_Cache.Solution",
        "documentation": {}
    },
    {
        "label": "LRUCache",
        "kind": 6,
        "importPath": "linked_list.meduim.146_LRU_Cache.Solution",
        "description": "linked_list.meduim.146_LRU_Cache.Solution",
        "peekOfCode": "class LRUCache(object):\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = DoublyListNode(0, 0)\n        self.tail = DoublyListNode(0, 0)        \n    #remove the node from the dll\n    def remove(self, node):\n        if node.key not in self.cache:\n            return ",
        "detail": "linked_list.meduim.146_LRU_Cache.Solution",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "linked_list.meduim.146_LRU_Cache.Solution",
        "description": "linked_list.meduim.146_LRU_Cache.Solution",
        "peekOfCode": "obj = LRUCache(2)\nobj.put(1, \"hi\")\nobj.put(2, \"hey\")\n#2, 1\nparam_1 = obj.get(2)\n#2, 3\nobj.put(3,\"hiyo\")\nparam_1 = obj.get(2)\n#2, 4\nobj.put(4, \"wow\")",
        "detail": "linked_list.meduim.146_LRU_Cache.Solution",
        "documentation": {}
    },
    {
        "label": "param_1",
        "kind": 5,
        "importPath": "linked_list.meduim.146_LRU_Cache.Solution",
        "description": "linked_list.meduim.146_LRU_Cache.Solution",
        "peekOfCode": "param_1 = obj.get(2)\n#2, 3\nobj.put(3,\"hiyo\")\nparam_1 = obj.get(2)\n#2, 4\nobj.put(4, \"wow\")",
        "detail": "linked_list.meduim.146_LRU_Cache.Solution",
        "documentation": {}
    },
    {
        "label": "param_1",
        "kind": 5,
        "importPath": "linked_list.meduim.146_LRU_Cache.Solution",
        "description": "linked_list.meduim.146_LRU_Cache.Solution",
        "peekOfCode": "param_1 = obj.get(2)\n#2, 4\nobj.put(4, \"wow\")",
        "detail": "linked_list.meduim.146_LRU_Cache.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "description": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution(object):",
        "detail": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "description": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "peekOfCode": "class Solution(object):\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(0, head)\n        l = dummy\n        r = head\n        for i in range(n):\n            r = r.next\n        while r:\n            l = l.next\n            r = r.next",
        "detail": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist1",
        "kind": 5,
        "importPath": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "description": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "peekOfCode": "linkedlist1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nlinkedlist2 = ListNode(1)\nlinkedlist3 = ListNode(1, 2)\nSolution().removeNthFromEnd(linkedlist1, 2)",
        "detail": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist2",
        "kind": 5,
        "importPath": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "description": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "peekOfCode": "linkedlist2 = ListNode(1)\nlinkedlist3 = ListNode(1, 2)\nSolution().removeNthFromEnd(linkedlist1, 2)",
        "detail": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist3",
        "kind": 5,
        "importPath": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "description": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "peekOfCode": "linkedlist3 = ListNode(1, 2)\nSolution().removeNthFromEnd(linkedlist1, 2)",
        "detail": "linked_list.meduim.19_Remove_Nth_Node_From_End_of_List.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.287_Find_the_Duplicate_Number.Solution",
        "description": "linked_list.meduim.287_Find_the_Duplicate_Number.Solution",
        "peekOfCode": "class Solution(object):\n    def findDuplicate(self, nums):\n        #find collision\n        s, f = 0, 0\n        while s != f or s == 0:\n            #s.next\n            s = nums[s]\n            #f.next.next\n            f = nums[f] \n            f = nums[f]",
        "detail": "linked_list.meduim.287_Find_the_Duplicate_Number.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "description": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution(object):",
        "detail": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "description": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "peekOfCode": "class Solution(object):\n    def addTwoNumbersSol1(self, l1, l2):\n        p1 = \"\"\n        p2 = \"\"\n        prev = None\n        while l1:\n            nxt = l1.next\n            l1.next = prev\n            prev = l1\n            l1 = nxt",
        "detail": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist1",
        "kind": 5,
        "importPath": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "description": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "peekOfCode": "linkedlist1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nlinkedlist2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().addTwoNumbers(linkedlist1, linkedlist2))",
        "detail": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist2",
        "kind": 5,
        "importPath": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "description": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "peekOfCode": "linkedlist2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nprint(Solution().addTwoNumbers(linkedlist1, linkedlist2))",
        "detail": "linked_list.meduim.2_Add_Two_Numbers.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "description": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        res = str(self.val)\n        if self.next:\n            res += \"->\" + str(self.next)\n        return res\nclass Solution(object):",
        "detail": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "description": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "peekOfCode": "class Solution(object):\n    def splitListToParts(self, head, k):\n        length = 0\n        cur = head\n        dummy = head\n        node = dummy\n        while cur:\n            cur = cur.next\n            length+=1\n        res = []",
        "detail": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "documentation": {}
    },
    {
        "label": "linkedlist2",
        "kind": 5,
        "importPath": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "description": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "peekOfCode": "linkedlist2 = ListNode(1, ListNode(2, ListNode(3)))\nprint(Solution().splitListToParts(linkedlist2, 5))",
        "detail": "linked_list.meduim.725_Split_Linked_List_in_Parts.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):\n            return False\n        if(p.val != q.val):\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\np = TreeNode(1, TreeNode(2), TreeNode(3))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "p = TreeNode(1, TreeNode(2), TreeNode(3))\nq = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "q = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):\n        if(root is None):\n            return 0\n        return 1 + max(self.length(root.left), self.length(root.right))\nright = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "right",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "right = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left2",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "tree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "solution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "balanced",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "balanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        return str(self.val)\nclass Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:\n            self.print(head.next) \n    def reverseList(self, head):\n        prev = None\n        current = head\n        while current is not None:\n            next = current.next",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "node",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "node = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8))))))))\nsolution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "solution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "description": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        l, r = 0, 1\n        profit = 0\n        while r < len(prices):\n            if prices[r] > prices[l]:\n                profit = max(profit, prices[r] - prices[l])\n            else:\n                l = r\n            r+=1",
        "detail": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.hard.239_Sliding_Window_Maximum.Solution",
        "description": "sliding_window.hard.239_Sliding_Window_Maximum.Solution",
        "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        res = []\n        q = collections.deque()\n        l = 0\n        for r in range(len(nums)):\n            print(r)\n            #remove all smaller values at the end of the dequeue\n            while q and nums[r] > nums[q[-1]]:\n                q.pop()",
        "detail": "sliding_window.hard.239_Sliding_Window_Maximum.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.hard.76_Minimum_Window_Substring.Solution",
        "description": "sliding_window.hard.76_Minimum_Window_Substring.Solution",
        "peekOfCode": "class Solution(object):\n    def minWindow(self, s, t):\n        if(len(t) == 0 or len(t) > len(s)):\n            return \"\"\n        countS, countT = {}, {}\n        minWindow = float(\"infinity\")\n        res = [-1, -1]\n        l = 0\n        #fill the countT map\n        for i in t:",
        "detail": "sliding_window.hard.76_Minimum_Window_Substring.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "description": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        l, r = 0, 0\n        res = 0\n        while r < len(s):\n            i = s[r]\n            curr = s[l:r]\n            if i in curr:\n                size = r - l\n                if res < size:",
        "detail": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "description": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "peekOfCode": "class Solution(object):\n    def characterReplacement(self, s, k):\n        l = 0\n        curr = 0\n        freq = defaultdict(int)\n        maxF = 0\n        for r in range(len(s)):\n            freq[s[r]] += 1\n            maxF = max(maxF, freq[s[r]])\n            if (r - l + 1) - maxF > k:",
        "detail": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.meduim.567_Permutation_in_String.Solution",
        "description": "sliding_window.meduim.567_Permutation_in_String.Solution",
        "peekOfCode": "class Solution(object):\n   def checkInclusion(self, s1, s2):\n        freqS1 = {i: 0 for i in string.ascii_lowercase}\n        freqS2 = {i: 0 for i in string.ascii_lowercase}\n        for i in s1:\n            freqS1[i] += 1\n        l = 0\n        for r in range(len(s2)):\n            freqS2[s2[r]] += 1\n            if (r - l + 1) > len(s1):",
        "detail": "sliding_window.meduim.567_Permutation_in_String.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.easy.20. Valid Parentheses.Solution",
        "description": "stacks.easy.20. Valid Parentheses.Solution",
        "peekOfCode": "class Solution(object):\n    def isValid1(self, s):\n        stack = []\n        closed = {  ')' : '(',\n                    '}' : '{',\n                    ']' : '['\n                }\n        for i in s:\n            if i in closed:\n                if stack[-1] == closed[i] and stack:",
        "detail": "stacks.easy.20. Valid Parentheses.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "description": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "peekOfCode": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        maxArea, stack = 0, []\n        heights.append(0)\n        for i, j in enumerate(heights):\n            startIndex = i\n            while stack and stack[-1][0] > j:\n                value, index = stack.pop()\n                maxArea = max(maxArea, value * (i - index))\n                startIndex = index",
        "detail": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "description": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "peekOfCode": "class Solution(object):\n    def evalRPN(self, tokens):\n        stack = []\n        for i in tokens:\n            if i == '+':\n                right = stack.pop()\n                left = stack.pop()\n                stack.append(left + right)\n            elif i == '-':\n                right = stack.pop()",
        "detail": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "documentation": {}
    },
    {
        "label": "MinStack",
        "kind": 6,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "class MinStack(object):\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)\n        if self.minStack:\n            curr = self.minStack[-1]\n            if val < curr:\n                self.minStack.append(val)",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "obj = MinStack()\nobj.push(1)\nobj.push(2)\nobj.pop()\nparam_3 = obj.top()\nparam_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "param_3",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "param_3 = obj.top()\nparam_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "param_4",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "param_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.22_Generate_Parentheses.Solution",
        "description": "stacks.meduim.22_Generate_Parentheses.Solution",
        "peekOfCode": "class Solution(object):\n    def generateParenthesis(self, n):\n        results = []\n        entry = []\n        def generate(open, closed):\n            if open == closed == n:\n                results.append(\"\".join(entry))\n                return\n            if open < n:\n                entry.append(\"(\")",
        "detail": "stacks.meduim.22_Generate_Parentheses.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.739_Daily_Temperatures.Solution",
        "description": "stacks.meduim.739_Daily_Temperatures.Solution",
        "peekOfCode": "class Solution(object):\n    def dailyTemperatures(self, temperatures):\n        result = [0] * len(temperatures) \n        stack = [] #indexes\n        for index, temp in enumerate(temperatures):\n            while stack and temp > temperatures[stack[-1]]:\n                poppedIndex = stack.pop()\n                result[poppedIndex] = (index - poppedIndex)\n            stack.append(index)\n        return result ",
        "detail": "stacks.meduim.739_Daily_Temperatures.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.853_Car_Fleet.Solution",
        "description": "stacks.meduim.853_Car_Fleet.Solution",
        "peekOfCode": "class Solution(object):\n    def carFleet(self, target, position, speed):\n        pairs = [[p, s] for p, s in zip(position, speed)]\n        stack = []\n        for p, s in sorted(pairs)[::-1]:\n            distance = (target - p)/s\n            stack.append(distance)\n            if len(stack) >= 2 and stack[-2] < stack[-1]:\n                stack.pop()\n        return len(stack)",
        "detail": "stacks.meduim.853_Car_Fleet.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def __str__(self):\n        output = []\n        self.pretty_print(output, 0)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        if not p and not q:\n            return True\n        if not p or not q or (p.val != q.val):\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\np = [1,2,3,4]\nq = [1,2,3]\n# Create TreeNode variables",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "p = [1,2,3,4]\nq = [1,2,3]\n# Create TreeNode variables\np_tree = TreeNode.build_tree(p, 0)\nq_tree = TreeNode.build_tree(q, 0)\n# Invert the binary tree\nsameTree = Solution().isSameTree(p_tree, q_tree)\nprint(sameTree)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "q = [1,2,3]\n# Create TreeNode variables\np_tree = TreeNode.build_tree(p, 0)\nq_tree = TreeNode.build_tree(q, 0)\n# Invert the binary tree\nsameTree = Solution().isSameTree(p_tree, q_tree)\nprint(sameTree)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "p_tree",
        "kind": 5,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "p_tree = TreeNode.build_tree(p, 0)\nq_tree = TreeNode.build_tree(q, 0)\n# Invert the binary tree\nsameTree = Solution().isSameTree(p_tree, q_tree)\nprint(sameTree)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "q_tree",
        "kind": 5,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "q_tree = TreeNode.build_tree(q, 0)\n# Invert the binary tree\nsameTree = Solution().isSameTree(p_tree, q_tree)\nprint(sameTree)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "sameTree",
        "kind": 5,
        "importPath": "trees.easy.100_Same_Tree.Solution",
        "description": "trees.easy.100_Same_Tree.Solution",
        "peekOfCode": "sameTree = Solution().isSameTree(p_tree, q_tree)\nprint(sameTree)",
        "detail": "trees.easy.100_Same_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def pretty_print(self, level=0):\n        prefix = '    ' * level\n        print(prefix, self.val)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def maxDepth(self, root):\n        return 0 if not root else 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n# Create the binary tree with the values [4,2,7,1,3,6,9]\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.left",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.right",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.left",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.right",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "root.right.right = TreeNode(9)\n# Invert the binary tree\nmaxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "maxDepth",
        "kind": 5,
        "importPath": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "description": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "peekOfCode": "maxDepth = Solution().maxDepth(root)\nprint(maxDepth)",
        "detail": "trees.easy.104_Maximum_Depth_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def pretty_print(self, level=0):\n        prefix = '    ' * level\n        print(prefix, self.val)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution2",
        "kind": 6,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "class Solution2(object):\n    def isBalanced(self, root):\n        if not root:\n            return True\n        l = self.height(root.left)\n        r = self.height(root.right)\n        d = abs(l - r)\n        return d <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def height(self, root):\n        if not root:",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def explore(root):\n            if not root:\n                return [True, 0]\n            l = explore(root.left)\n            r = explore(root.right)\n            return [(l[0] and r[0] and (abs(l[1] - r[1]) <= 1)), 1 + max(l[1], r[1])] \n        return explore(root)[0]\n# Create the tree nodes",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(2)\nroot.left.left = TreeNode(3)\nroot.right.right = TreeNode(3)\nroot.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.left = TreeNode(2)\nroot.right = TreeNode(2)\nroot.left.left = TreeNode(3)\nroot.right.right = TreeNode(3)\nroot.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.right = TreeNode(2)\nroot.left.left = TreeNode(3)\nroot.right.right = TreeNode(3)\nroot.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.left",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.left.left = TreeNode(3)\nroot.right.right = TreeNode(3)\nroot.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.right",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.right.right = TreeNode(3)\nroot.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.left.left",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.left.left.left = TreeNode(4)\nroot.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.right.right",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "root.right.right.right = TreeNode(4)\n# Invert the binary tree\ntree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "description": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "peekOfCode": "tree = Solution().isBalanced(root)\nprint(tree)",
        "detail": "trees.easy.110_Balanced_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def pretty_print(self, level=0):\n        prefix = '    ' * level\n        print(prefix, self.val)",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def invertTree(self, root):\n        if root == None:\n            return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.right)\n        self.invertTree(root.left)\n        return root\n# Create the binary tree with the values [4,2,7,1,3,6,9]\nroot = TreeNode(4)",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.left",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.right",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.left",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right.right",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "root.right.right = TreeNode(9)\n# Invert the binary tree\ninverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "inverted_root",
        "kind": 5,
        "importPath": "trees.easy.226_Invert_Binary_Tree.Solution",
        "description": "trees.easy.226_Invert_Binary_Tree.Solution",
        "peekOfCode": "inverted_root = Solution().invertTree(root)\n# Print the inverted tree\ninverted_root.pretty_print()",
        "detail": "trees.easy.226_Invert_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def pretty_print(self, level=0):\n        prefix = '    ' * level\n        print(prefix, self.val)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def __init__(self) -> None:\n        self.res = 0\n    def diameterOfBinaryTree(self, root):      \n        res = 0\n        def dfs(root):\n            if not root:\n                return -1\n            leftHeight = dfs(root.left)\n            rightHeight = dfs(root.right)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "root = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n# Invert the binary tree\nres = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "root.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n# Invert the binary tree\nres = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.right",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "root.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n# Invert the binary tree\nres = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.left",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "root.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\n# Invert the binary tree\nres = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "root.left.right",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "root.left.right = TreeNode(5)\n# Invert the binary tree\nres = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "description": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "peekOfCode": "res = Solution().diameterOfBinaryTree(root)\nprint(res)",
        "detail": "trees.easy.543_Diameter_of_Binary_Tree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "trees.boilerplate",
        "description": "trees.boilerplate",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return str(self.val)\n    def __str__(self):\n        output = []\n        self.pretty_print(output, 0)",
        "detail": "trees.boilerplate",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "trees.boilerplate",
        "description": "trees.boilerplate",
        "peekOfCode": "class Solution(object):\n    def someMethod(self, root):\n        print(root)\n        return False\nroot = TreeNode.build_tree([1, 2, 3, 4, 5])\nsameTree = Solution().someMethod(root)\nprint(sameTree)",
        "detail": "trees.boilerplate",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "trees.boilerplate",
        "description": "trees.boilerplate",
        "peekOfCode": "root = TreeNode.build_tree([1, 2, 3, 4, 5])\nsameTree = Solution().someMethod(root)\nprint(sameTree)",
        "detail": "trees.boilerplate",
        "documentation": {}
    },
    {
        "label": "sameTree",
        "kind": 5,
        "importPath": "trees.boilerplate",
        "description": "trees.boilerplate",
        "peekOfCode": "sameTree = Solution().someMethod(root)\nprint(sameTree)",
        "detail": "trees.boilerplate",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "description": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "peekOfCode": "class Solution(object):\n    def isPalindrome(self, s):\n        text = s.lower()\n        length = len(text) \n        leftPointer = 0\n        rightPointer = length - 1\n        while leftPointer < rightPointer:\n            while (leftPointer < rightPointer) and not (text[leftPointer].isdigit() or text[leftPointer].isalpha()):\n                leftPointer += 1\n            while (leftPointer < rightPointer) and not (text[rightPointer].isdigit() or text[rightPointer].isalpha()):",
        "detail": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.easy.1984_Minimum_Difference_Between_Highest_and_Lowest_of_K_Scores.Solution",
        "description": "two_pointers.easy.1984_Minimum_Difference_Between_Highest_and_Lowest_of_K_Scores.Solution",
        "peekOfCode": "class Solution(object):\n    def minimumDifference(self, nums, k):\n        arr = sorted(nums)\n        l, r = 0, k - 1\n        diff = arr[len(arr) - 1] - arr[0]\n        while r < len(arr):\n            cur = arr[r] - arr[l]\n            print(cur)\n            diff = min(diff, cur)\n            r+=1",
        "detail": "two_pointers.easy.1984_Minimum_Difference_Between_Highest_and_Lowest_of_K_Scores.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.easy.680_Valid_Palindrome_II.Solution",
        "description": "two_pointers.easy.680_Valid_Palindrome_II.Solution",
        "peekOfCode": "class Solution(object):\n    def validPalindrome(self, s):\n        l, r = 0, len(s) - 1\n        while l <= r:\n            if(s[l] != s[r]):\n                str1 = s[:l] + s[l+1:]\n                str2 = s[:r] + s[r+1:]\n                return str1 == str1[::-1] or str2 == str2[::-1]\n            l += 1\n            r -= 1",
        "detail": "two_pointers.easy.680_Valid_Palindrome_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "description": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "peekOfCode": "class Solution(object):\n    def trap(self, height):\n        length = len(height)\n        l, r, level = 0, length - 1, 0\n        maxL, maxR = height[l], height[r]\n        while l < r:\n            waterLevel = 0\n            if maxL < maxR:\n                l += 1\n                waterLevel = maxL - height[l]",
        "detail": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "description": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "peekOfCode": "arr = [0,1,0,2,1,0,1,3,2,1,2,1]\nprint(Solution().trap(arr))",
        "detail": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.11. Container With Most Water.Solution",
        "description": "two_pointers.meduim.11. Container With Most Water.Solution",
        "peekOfCode": "class Solution(object):\n    def maxArea(self, walls):\n        l, r = 0, len(walls) - 1\n        maxArea = 0\n        while l < r:\n            area = min(walls[l], walls[r]) * (r - l)\n            maxArea = area if area > maxArea else maxArea\n            if(walls[l] < walls[r]):\n                l+=1\n            else:",
        "detail": "two_pointers.meduim.11. Container With Most Water.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.11. Container With Most Water.Solution",
        "description": "two_pointers.meduim.11. Container With Most Water.Solution",
        "peekOfCode": "arr = [1,1]\nprint(Solution().maxArea(arr))",
        "detail": "two_pointers.meduim.11. Container With Most Water.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.15. 3Sum.Solution",
        "description": "two_pointers.meduim.15. 3Sum.Solution",
        "peekOfCode": "class Solution(object):\n    def threeSum(self, nums):\n        sums = []\n        numbers = list(nums)\n        numbers.sort()\n        for index, number in enumerate(numbers):\n            if index > 0 and number == numbers[index - 1]:\n                continue\n            l, r = index + 1, len(numbers) - 1\n            while l < r:",
        "detail": "two_pointers.meduim.15. 3Sum.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.15. 3Sum.Solution",
        "description": "two_pointers.meduim.15. 3Sum.Solution",
        "peekOfCode": "arr = [-1,0,1,2,-1,-4]\nprint(Solution().threeSum(arr))",
        "detail": "two_pointers.meduim.15. 3Sum.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "description": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "peekOfCode": "class Solution(object):\n    def twoSum(self, numbers, target):\n        rPointer = len(numbers) - 1\n        lPointer = 0\n        while lPointer < rPointer:\n            sum = numbers[lPointer] + numbers[rPointer]\n            if sum == target:\n                return [lPointer + 1, rPointer + 1]\n            if sum < target:\n                lPointer+=1",
        "detail": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "description": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "peekOfCode": "arr = [1,2,3,4,5]\nprint(Solution().twoSum(arr, 5))",
        "detail": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "documentation": {}
    }
]