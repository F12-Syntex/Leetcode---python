[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "TreeNode",
        "description": "TreeNode",
        "isExtraImport": true,
        "detail": "TreeNode",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "description": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "peekOfCode": "class Solution(object):\n    def longestConsecutive(self, nums):\n        hashset, maximum = set(nums), 0\n        for i in hashset:\n            if i-1 not in hashset:\n                sequence = 1\n                while (i+sequence) in hashset:\n                    sequence += 1\n                maximum = max(maximum, sequence)\n        return maximum",
        "detail": "arrays_and_hashing.meduim.128_Longest_Consecutive_Sequence.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "description": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "peekOfCode": "class Solution(object):\n    def productExceptSelf(self, nums):\n        answer = [0] * len(nums)\n        sum = 1\n        zeroIndex = -1\n        for i in range(len(nums)):\n            value = nums[i]\n            if value == 0:\n                if zeroIndex != -1:\n                    return answer",
        "detail": "arrays_and_hashing.meduim.238_Product_of_Array_Except_Self.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "description": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "peekOfCode": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        topMap = [[] for _ in range(len(nums) + 1)]\n        map = self.mapify(nums)\n        for key in map:\n            value = map[key]\n            topMap[value].append(key)\n        j = 0\n        topK = [[] for _ in range(k)]\n        for i in range(len(topMap) - 1, -1, -1):",
        "detail": "arrays_and_hashing.meduim.347_Top_K_Frequent_Elements.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "description": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "peekOfCode": "class Solution(object):\n    def isValidSudoku(self, board):\n        for rowIndex in range(len(board)):\n            row = board[rowIndex]\n            for colIndex in range(len(row)):\n                if not self.verify(board, rowIndex, colIndex):\n                    return False\n        return True\n    def verify(self, board, rowIndex, colIndex):\n        valid = True",
        "detail": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "description": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "peekOfCode": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nprint(Solution().isValidSudoku(board))",
        "detail": "arrays_and_hashing.meduim.36_Valid_Sudoku.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.easy.704_Binary_Search.Solution",
        "description": "binary_search.easy.704_Binary_Search.Solution",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            middleIndex = l + ((r - l) // 2)\n            if nums[middleIndex] == target:\n                return middleIndex\n            if nums[middleIndex] < target:\n                l = middleIndex + 1\n            else:",
        "detail": "binary_search.easy.704_Binary_Search.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "description": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        l, r = 0, len(nums) - 1\n        res = nums[0]\n        while l <= r:\n            m = ( l + r ) // 2\n            res = min(res, nums[m])\n            if nums[l] < nums[r]:\n                return min(nums[l], res)\n            if(nums[m] == nums[l]):",
        "detail": "binary_search.hard.154_Find_Minimum_in_Rotated_Sorted_Array_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "description": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "peekOfCode": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        size = len(nums1) + len(nums2)\n        half = size // 2\n        #if nums2 is empty\n        if len(nums2) == 0:\n            size = len(nums1) - 1\n            if (size+1) % 2:\n                return nums1[size // 2] / 1\n            else:",
        "detail": "binary_search.hard.4_Median_of_Two_Sorted_Arrays.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "description": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        l, r = 0, len(nums) - 1\n        res = nums[0]\n        while l <= r:\n            m = ( l + r ) // 2\n            res = min(res, nums[m])\n            if nums[l] <= nums[r]:\n                return min(nums[l], res)\n            if nums[m] >= nums[l]:",
        "detail": "binary_search.meduim.153_Find_Minimum_in_Rotated_Sorted_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "description": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            elif nums[m] >= nums[l]:\n                if target > nums[m] or target < nums[l]:\n                    l = m + 1",
        "detail": "binary_search.meduim.33_Search_in_Rotated_Sorted_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "description": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "peekOfCode": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        m = len(matrix)\n        n = len(matrix[0])\n        l, r = 0, (m * n) - 1\n        while l <= r:\n            m = (l + r) // 2\n            arrayIndex = m // n\n            cellIndex = m - (arrayIndex * n)\n            print(m)",
        "detail": "binary_search.meduim.74_Search_a_2D_Matrix.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "description": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "peekOfCode": "class Solution(object):\n    def minEatingSpeed(self, piles, h):\n        l, r = 1, max(piles)\n        minimum = r\n        while l <= r:\n            k = (l + r) // 2\n            hours = 0\n            for p in piles:\n                hours += math.ceil(p / k)\n            if hours <= h:",
        "detail": "binary_search.meduim.875_Koko_Eating_Bananas.Solution",
        "documentation": {}
    },
    {
        "label": "TimeMap",
        "kind": 6,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "class TimeMap(object):\n    def __init__(self):\n        self.store = {}\n    def set(self, key, value, timestamp):\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])\n    def get(self, key, timestamp):\n        res = \"\"\n        if key not in self.store:",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "obj = TimeMap()\nobj.set(1, 1, 1)\nparam_2 = obj.get(1,1)\nprint(param_2)",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "param_2",
        "kind": 5,
        "importPath": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "description": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "peekOfCode": "param_2 = obj.get(1,1)\nprint(param_2)",
        "detail": "binary_search.meduim.981_Time_Based_Key-Value_Store.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "description": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        l, r = 0, (k - 1)\n        maximum = [0] * (len(nums) - r)\n        heap = []\n        # find max in first range\n        for i in range(l, r + 1):\n            heapq.heappush(heap, (-nums[i], i))  # store negation of elements in the heap\n        element = -heapq.heappop(heap)[0]  # negate the value again to get the maximum element\n        print(element)",
        "detail": "dailies.hard.239_Sliding_Window_Maximum.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1025_Divisor_Game.Solution",
        "description": "dp.easy.1025_Divisor_Game.Solution",
        "peekOfCode": "class Solution(object):\n    def divisorGame(self, n):\n        return n&1 == 0\nprint(str(Solution().divisorGame(3)))",
        "detail": "dp.easy.1025_Divisor_Game.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "description": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "peekOfCode": "class Solution(object):\n    def tribonacci(self, n):\n        arr = [0, 1, 1]\n        if len(arr) >= n:\n            return arr[n]\n        for i in range(3, n):\n            num = arr[0] + arr[1] + arr[2]\n            self.leftShift(arr)\n            arr.append(num)\n        return self.sum(arr)",
        "detail": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "class Solution(object):\n    def generate(self, numRows):\n        dp = []\n        for i in range(1, numRows + 1):\n            array = []\n            for x in range(1, i+1):\n                if(x == 1 or x == i):\n                    array.append(1)\n                    continue\n                parent = dp[i - 2]",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.generate(3))",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.119_Pascals_Triangle_II.Solution",
        "description": "dp.easy.119_Pascals_Triangle_II.Solution",
        "peekOfCode": "class Solution(object):\n    def getRow(self, rowIndex):\n        arr = [0] * (rowIndex+1)\n        for row in range(rowIndex + 2):\n            startIndex = 0\n            endIndex = row-1\n            original = list(arr)\n            original[startIndex] = 1\n            original[endIndex] = 1\n            for col in range(row):",
        "detail": "dp.easy.119_Pascals_Triangle_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "description": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        left_pointer = 0\n        right_pointer = 1\n        max_profit = 0\n        for i in range(1, len(prices)):\n            value = prices[i]\n            if value < prices[left_pointer]:\n                left_pointer = i\n            right_pointer+=1",
        "detail": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "description": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def getMaximumGenerated(self, n):\n        if n < 2:\n            return n\n        arr = [0] * (n+1)\n        arr[1] = 1\n        max = arr[1]\n        for i in range(2, n+1):\n            if(i&1 == 0):\n                arr[i] = arr[i//2]",
        "detail": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "class Solution(object):\n    def countBits(self, n):\n        binary = [0]\n        msb = 1\n        for i in range(1, n + 1):\n            mbv = (2 ** msb)\n            if mbv == i:\n                msb+=1\n                binary.append(1)\n                continue",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.countBits(5))",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.392_Is_Subsequence.Solution",
        "description": "dp.easy.392_Is_Subsequence.Solution",
        "peekOfCode": "class Solution(object):\n    def isSubsequence(self, string, text):\n        subsequence = list(string)\n        j = 0\n        for i in range(len(text)):\n            if(text[i] == subsequence[j]):\n                char = subsequence[j]\n                j+=1\n                if(len(subsequence) == j):\n                    return True",
        "detail": "dp.easy.392_Is_Subsequence.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "description": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "peekOfCode": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        if len(cost) == 0:\n            return 0\n        if len(cost) == 1:\n            return cost[0]\n        if len(cost) == 2:\n            return min(cost[0], cost[1])\n        cost.append(0)\n        cost.append(0)",
        "detail": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "class Solution(object):\n    def allPossibleFBT(self, n):\n        #remember prev calculations\n        cache = {\n            0 : [],\n            1 : [TreeNode()]\n        }\n        #explore a given noumber of nodes\n        def explore(n):\n            #no full binary trees can be produced with an even number of nodes",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "result = Solution().allPossibleFBT(5)\nfor tree in result:\n    print(\"-\", tree)",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __str__(self):\n        return str(self.preorder(self))\n    def preorder(self, node):\n        if node is None:\n            return \"None\"",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):\n            return False\n        if(p.val != q.val):\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\np = TreeNode(1, TreeNode(2), TreeNode(3))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "p = TreeNode(1, TreeNode(2), TreeNode(3))\nq = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "q = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):\n        if(root is None):\n            return 0\n        return 1 + max(self.length(root.left), self.length(root.right))\nright = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "right",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "right = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left2",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "tree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "solution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "balanced",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "balanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        return str(self.val)\nclass Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:\n            self.print(head.next) \n    def reverseList(self, head):\n        prev = None\n        current = head\n        while current is not None:\n            next = current.next",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "node",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "node = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8))))))))\nsolution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "solution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "description": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        l, r = 0, 1\n        profit = 0\n        while r < len(prices):\n            if prices[r] > prices[l]:\n                profit = max(profit, prices[r] - prices[l])\n            else:\n                l = r\n            r+=1",
        "detail": "sliding_window.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "description": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        l, r = 0, 0\n        res = 0\n        while r < len(s):\n            i = s[r]\n            curr = s[l:r]\n            if i in curr:\n                size = r - l\n                if res < size:",
        "detail": "sliding_window.meduim.3_Longest_Substring_Without_Repeating_Characters.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "description": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "peekOfCode": "class Solution(object):\n    def characterReplacement(self, s, k):\n        l = 0\n        curr = 0\n        freq = defaultdict(int)\n        maxF = 0\n        for r in range(len(s)):\n            freq[s[r]] += 1\n            maxF = max(maxF, freq[s[r]])\n            if (r - l + 1) - maxF > k:",
        "detail": "sliding_window.meduim.424_Longest_Repeating_Character_Replacement.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.easy.20. Valid Parentheses.Solution",
        "description": "stacks.easy.20. Valid Parentheses.Solution",
        "peekOfCode": "class Solution(object):\n    def isValid1(self, s):\n        stack = []\n        closed = {  ')' : '(',\n                    '}' : '{',\n                    ']' : '['\n                }\n        for i in s:\n            if i in closed:\n                if stack[-1] == closed[i] and stack:",
        "detail": "stacks.easy.20. Valid Parentheses.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "description": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "peekOfCode": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        maxArea, stack = 0, []\n        heights.append(0)\n        for i, j in enumerate(heights):\n            startIndex = i\n            while stack and stack[-1][0] > j:\n                value, index = stack.pop()\n                maxArea = max(maxArea, value * (i - index))\n                startIndex = index",
        "detail": "stacks.hard.84_Largest_Rectangle_in_Histogram.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "description": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "peekOfCode": "class Solution(object):\n    def evalRPN(self, tokens):\n        stack = []\n        for i in tokens:\n            if i == '+':\n                right = stack.pop()\n                left = stack.pop()\n                stack.append(left + right)\n            elif i == '-':\n                right = stack.pop()",
        "detail": "stacks.meduim.150_Evaluate_Reverse_Polish_Notation.Solution",
        "documentation": {}
    },
    {
        "label": "MinStack",
        "kind": 6,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "class MinStack(object):\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)\n        if self.minStack:\n            curr = self.minStack[-1]\n            if val < curr:\n                self.minStack.append(val)",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "obj",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "obj = MinStack()\nobj.push(1)\nobj.push(2)\nobj.pop()\nparam_3 = obj.top()\nparam_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "param_3",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "param_3 = obj.top()\nparam_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "param_4",
        "kind": 5,
        "importPath": "stacks.meduim.155_Min_Stack.Solution",
        "description": "stacks.meduim.155_Min_Stack.Solution",
        "peekOfCode": "param_4 = obj.getMin()",
        "detail": "stacks.meduim.155_Min_Stack.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.22_Generate_Parentheses.Solution",
        "description": "stacks.meduim.22_Generate_Parentheses.Solution",
        "peekOfCode": "class Solution(object):\n    def generateParenthesis(self, n):\n        results = []\n        entry = []\n        def generate(open, closed):\n            if open == closed == n:\n                results.append(\"\".join(entry))\n                return\n            if open < n:\n                entry.append(\"(\")",
        "detail": "stacks.meduim.22_Generate_Parentheses.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.739_Daily_Temperatures.Solution",
        "description": "stacks.meduim.739_Daily_Temperatures.Solution",
        "peekOfCode": "class Solution(object):\n    def dailyTemperatures(self, temperatures):\n        result = [0] * len(temperatures) \n        stack = [] #indexes\n        for index, temp in enumerate(temperatures):\n            while stack and temp > temperatures[stack[-1]]:\n                poppedIndex = stack.pop()\n                result[poppedIndex] = (index - poppedIndex)\n            stack.append(index)\n        return result ",
        "detail": "stacks.meduim.739_Daily_Temperatures.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "stacks.meduim.853_Car_Fleet.Solution",
        "description": "stacks.meduim.853_Car_Fleet.Solution",
        "peekOfCode": "class Solution(object):\n    def carFleet(self, target, position, speed):\n        pairs = [[p, s] for p, s in zip(position, speed)]\n        stack = []\n        for p, s in sorted(pairs)[::-1]:\n            distance = (target - p)/s\n            stack.append(distance)\n            if len(stack) >= 2 and stack[-2] < stack[-1]:\n                stack.pop()\n        return len(stack)",
        "detail": "stacks.meduim.853_Car_Fleet.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "description": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "peekOfCode": "class Solution(object):\n    def isPalindrome(self, s):\n        text = s.lower()\n        length = len(text) \n        leftPointer = 0\n        rightPointer = length - 1\n        while leftPointer < rightPointer:\n            while (leftPointer < rightPointer) and not (text[leftPointer].isdigit() or text[leftPointer].isalpha()):\n                leftPointer += 1\n            while (leftPointer < rightPointer) and not (text[rightPointer].isdigit() or text[rightPointer].isalpha()):",
        "detail": "two_pointers.easy.125_Valid_Palindrome.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "description": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "peekOfCode": "class Solution(object):\n    def trap(self, height):\n        length = len(height)\n        l, r, level = 0, length - 1, 0\n        maxL, maxR = height[l], height[r]\n        while l < r:\n            waterLevel = 0\n            if maxL < maxR:\n                l += 1\n                waterLevel = maxL - height[l]",
        "detail": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "description": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "peekOfCode": "arr = [0,1,0,2,1,0,1,3,2,1,2,1]\nprint(Solution().trap(arr))",
        "detail": "two_pointers.hard.42_Trapping_Rain_Water.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.11. Container With Most Water.Solution",
        "description": "two_pointers.meduim.11. Container With Most Water.Solution",
        "peekOfCode": "class Solution(object):\n    def maxArea(self, walls):\n        l, r = 0, len(walls) - 1\n        maxArea = 0\n        while l < r:\n            area = min(walls[l], walls[r]) * (r - l)\n            maxArea = area if area > maxArea else maxArea\n            if(walls[l] < walls[r]):\n                l+=1\n            else:",
        "detail": "two_pointers.meduim.11. Container With Most Water.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.11. Container With Most Water.Solution",
        "description": "two_pointers.meduim.11. Container With Most Water.Solution",
        "peekOfCode": "arr = [1,1]\nprint(Solution().maxArea(arr))",
        "detail": "two_pointers.meduim.11. Container With Most Water.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.15. 3Sum.Solution",
        "description": "two_pointers.meduim.15. 3Sum.Solution",
        "peekOfCode": "class Solution(object):\n    def threeSum(self, nums):\n        sums = []\n        numbers = list(nums)\n        numbers.sort()\n        for index, number in enumerate(numbers):\n            if index > 0 and number == numbers[index - 1]:\n                continue\n            l, r = index + 1, len(numbers) - 1\n            while l < r:",
        "detail": "two_pointers.meduim.15. 3Sum.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.15. 3Sum.Solution",
        "description": "two_pointers.meduim.15. 3Sum.Solution",
        "peekOfCode": "arr = [-1,0,1,2,-1,-4]\nprint(Solution().threeSum(arr))",
        "detail": "two_pointers.meduim.15. 3Sum.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "description": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "peekOfCode": "class Solution(object):\n    def twoSum(self, numbers, target):\n        rPointer = len(numbers) - 1\n        lPointer = 0\n        while lPointer < rPointer:\n            sum = numbers[lPointer] + numbers[rPointer]\n            if sum == target:\n                return [lPointer + 1, rPointer + 1]\n            if sum < target:\n                lPointer+=1",
        "detail": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "description": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "peekOfCode": "arr = [1,2,3,4,5]\nprint(Solution().twoSum(arr, 5))",
        "detail": "two_pointers.meduim.167_Two_Sum_II_Input_Array_Is_Sorted.Solution",
        "documentation": {}
    }
]