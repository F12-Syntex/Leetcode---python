[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.338_Counting_Bits.Solution",
        "description": "dp.338_Counting_Bits.Solution",
        "peekOfCode": "class Solution(object):\n    def countBits(self, n):\n        binary = [0]\n        msb = 1\n        for i in range(1, n + 1):\n            mbv = (2 ** msb)\n            if mbv == i:\n                msb+=1\n                binary.append(1)\n                continue",
        "detail": "dp.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.338_Counting_Bits.Solution",
        "description": "dp.338_Counting_Bits.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.countBits(5))",
        "detail": "dp.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):\n            return False\n        if(p.val != q.val):\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\np = TreeNode(1, TreeNode(2), TreeNode(3))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "p = TreeNode(1, TreeNode(2), TreeNode(3))\nq = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "q = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):\n        if(root is None):\n            return 0\n        return 1 + max(self.length(root.left), self.length(root.right))\nright = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "right",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "right = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left2",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "tree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "solution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "balanced",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "balanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        return str(self.val)\nclass Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:\n            self.print(head.next) \n    def reverseList(self, head):\n        prev = None\n        current = head\n        while current is not None:\n            next = current.next",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "node",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "node = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8))))))))\nsolution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "solution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    }
]