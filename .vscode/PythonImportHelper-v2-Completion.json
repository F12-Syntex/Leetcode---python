[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "importPath": "TreeNode",
        "description": "TreeNode",
        "isExtraImport": true,
        "detail": "TreeNode",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1025_Divisor_Game.Solution",
        "description": "dp.easy.1025_Divisor_Game.Solution",
        "peekOfCode": "class Solution(object):\n    def divisorGame(self, n):\n        return n&1 == 0\nprint(str(Solution().divisorGame(3)))",
        "detail": "dp.easy.1025_Divisor_Game.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "description": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "peekOfCode": "class Solution(object):\n    def tribonacci(self, n):\n        arr = [0, 1, 1]\n        if len(arr) >= n:\n            return arr[n]\n        for i in range(3, n):\n            num = arr[0] + arr[1] + arr[2]\n            self.leftShift(arr)\n            arr.append(num)\n        return self.sum(arr)",
        "detail": "dp.easy.1137_N_th_Tribonacci_Number.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "class Solution(object):\n    def generate(self, numRows):\n        dp = []\n        for i in range(1, numRows + 1):\n            array = []\n            for x in range(1, i+1):\n                if(x == 1 or x == i):\n                    array.append(1)\n                    continue\n                parent = dp[i - 2]",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.118_Pascals_Triangle.Solution",
        "description": "dp.easy.118_Pascals_Triangle.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.generate(3))",
        "detail": "dp.easy.118_Pascals_Triangle.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.119_Pascals_Triangle_II.Solution",
        "description": "dp.easy.119_Pascals_Triangle_II.Solution",
        "peekOfCode": "class Solution(object):\n    def getRow(self, rowIndex):\n        arr = [0] * (rowIndex+1)\n        for row in range(rowIndex + 2):\n            startIndex = 0\n            endIndex = row-1\n            original = list(arr)\n            original[startIndex] = 1\n            original[endIndex] = 1\n            for col in range(row):",
        "detail": "dp.easy.119_Pascals_Triangle_II.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "description": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        left_pointer = 0\n        right_pointer = 1\n        max_profit = 0\n        for i in range(1, len(prices)):\n            value = prices[i]\n            if value < prices[left_pointer]:\n                left_pointer = i\n            right_pointer+=1",
        "detail": "dp.easy.121_Best_Time_to_Buy_and_Sell_Stock.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "description": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "peekOfCode": "class Solution(object):\n    def getMaximumGenerated(self, n):\n        if n < 2:\n            return n\n        arr = [0] * (n+1)\n        arr[1] = 1\n        max = arr[1]\n        for i in range(2, n+1):\n            if(i&1 == 0):\n                arr[i] = arr[i//2]",
        "detail": "dp.easy.1646_Get_Maximum_in_Generated_Array.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "class Solution(object):\n    def countBits(self, n):\n        binary = [0]\n        msb = 1\n        for i in range(1, n + 1):\n            mbv = (2 ** msb)\n            if mbv == i:\n                msb+=1\n                binary.append(1)\n                continue",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "sol",
        "kind": 5,
        "importPath": "dp.easy.338_Counting_Bits.Solution",
        "description": "dp.easy.338_Counting_Bits.Solution",
        "peekOfCode": "sol = Solution()\nprint(sol.countBits(5))",
        "detail": "dp.easy.338_Counting_Bits.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.392_Is_Subsequence.Solution",
        "description": "dp.easy.392_Is_Subsequence.Solution",
        "peekOfCode": "class Solution(object):\n    def isSubsequence(self, string, text):\n        subsequence = list(string)\n        j = 0\n        for i in range(len(text)):\n            if(text[i] == subsequence[j]):\n                char = subsequence[j]\n                j+=1\n                if(len(subsequence) == j):\n                    return True",
        "detail": "dp.easy.392_Is_Subsequence.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "description": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "peekOfCode": "class Solution(object):\n    def minCostClimbingStairs(self, cost):\n        if len(cost) == 0:\n            return 0\n        if len(cost) == 1:\n            return cost[0]\n        if len(cost) == 2:\n            return min(cost[0], cost[1])\n        cost.append(0)\n        cost.append(0)",
        "detail": "dp.easy.746_Min_Cost_Climbing_Stairs.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "class Solution(object):\n    def allPossibleFBT(self, n):\n        #remember prev calculations\n        cache = {\n            0 : [],\n            1 : [TreeNode()]\n        }\n        #explore a given noumber of nodes\n        def explore(n):\n            #no full binary trees can be produced with an even number of nodes",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "peekOfCode": "result = Solution().allPossibleFBT(5)\nfor tree in result:\n    print(\"-\", tree)",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "description": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    def __str__(self):\n        return str(self.preorder(self))\n    def preorder(self, node):\n        if node is None:\n            return \"None\"",
        "detail": "dp.meduim.894_All_Possible_Full_Binary_Trees.TreeNode",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        if(p is None and q is None):\n            return True\n        if(p is None or q is None):\n            return False\n        if(p.val != q.val):\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\np = TreeNode(1, TreeNode(2), TreeNode(3))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "p = TreeNode(1, TreeNode(2), TreeNode(3))\nq = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "path-finding.100. SameTree.Solution",
        "description": "path-finding.100. SameTree.Solution",
        "peekOfCode": "q = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(str(Solution().isSameTree(p, q)))",
        "detail": "path-finding.100. SameTree.Solution",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root: TreeNode):\n        difference = abs(self.length(root.left) - self.length(root.right))\n        return difference <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    def length(self, root: TreeNode):\n        if(root is None):\n            return 0\n        return 1 + max(self.length(root.left), self.length(root.right))\nright = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "right",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "right = TreeNode(9)\nleft2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left2",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left2 = TreeNode(3, TreeNode(4), TreeNode(4))\nleft = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "left",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "left = TreeNode(2, left2, TreeNode(3))\ntree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "tree = TreeNode(1, left, right)\nsolution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "solution = Solution()  # Create an instance of the Solution class\nbalanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "balanced",
        "kind": 5,
        "importPath": "path-finding.110. Balanced Binary Tree.Solution",
        "description": "path-finding.110. Balanced Binary Tree.Solution",
        "peekOfCode": "balanced = solution.isBalanced(tree)  # Call the isBalanced method on the instance\nprint(balanced)",
        "detail": "path-finding.110. Balanced Binary Tree.Solution",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __str__(self) -> str:\n        return str(self.val)\nclass Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "class Solution(object):\n    def print(self, head):\n        print(head)\n        if head.next != None:\n            self.print(head.next) \n    def reverseList(self, head):\n        prev = None\n        current = head\n        while current is not None:\n            next = current.next",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "node",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "node = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6, ListNode(7, ListNode(8))))))))\nsolution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "recursion.206_ReverseLinkedList.Solution",
        "description": "recursion.206_ReverseLinkedList.Solution",
        "peekOfCode": "solution = Solution() \nsolution.print(solution.reverseList(node))",
        "detail": "recursion.206_ReverseLinkedList.Solution",
        "documentation": {}
    }
]